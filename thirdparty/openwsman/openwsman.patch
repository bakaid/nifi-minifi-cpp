diff -rupN openwsman-2.6.9/CMakeLists.txt openwsman-2.6.9-patched/CMakeLists.txt
--- openwsman-2.6.9/CMakeLists.txt	2018-11-20 09:09:43.000000000 +0100
+++ openwsman-2.6.9-patched/CMakeLists.txt	2019-08-01 15:48:44.000000000 +0200
@@ -22,7 +22,7 @@ if(COMMAND cmake_policy)
   cmake_policy(SET CMP0046 OLD)
   endif ( POLICY CMP0046 )
 endif(COMMAND cmake_policy)
-	      
+
 # where to look first for cmake modules, before ${CMAKE_ROOT}/Modules/ is checked
 SET(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/modules ${CMAKE_MODULE_PATH})
 
@@ -84,7 +84,7 @@ MACRO(NO_HEADERS_WARNING_EXPL optionName
    MESSAGE(STATUS "************************************")
    SET(HAVE_WARNINGS YES)
 ENDMACRO(NO_HEADERS_WARNING_EXPL)
-    
+
 # Macro for error message when header files not present, but build option
 # not explicitly declared
 MACRO(NO_HEADERS_WARNING optionName pkgName)
@@ -170,6 +170,12 @@ INCLUDE(FindOpenSSL)
 IF(OPENSSL_FOUND)
   SET(HAVE_SSL 1)
   SET(USE_OPENSSL 1)
+  INCLUDE_DIRECTORIES(${OPENSSL_INCLUDE_DIR})
+  message(OpenSSL found)
+  message(OPENSSL_INCLUDE_DIR: ${OPENSSL_INCLUDE_DIR})
+  message(OPENSSL_LIBRARIES: ${OPENSSL_LIBRARIES})
+ELSE(OPENSSL_FOUND)
+  SET(HAVE_SSL 0)
 ENDIF(OPENSSL_FOUND)
 
 IF( BUILD_RUBY )
@@ -260,7 +266,7 @@ ELSE ( NOT CURL_FOUND)
     STRING(COMPARE LESS ${CURL_VERSION_STRING} "7.12.0" result)
     IF(result LESS 0)
       MESSAGE( FATAL_ERROR " curl version ${CURL_VERSION_STRING} is too low, need 7.12.0 or greater" )
-    ENDIF(result LESS 0)    
+    ENDIF(result LESS 0)
   ENDIF(CURL_VERSION_STRING)
 ENDIF( NOT CURL_FOUND)
 
@@ -439,7 +445,7 @@ IF(HAVE_SA_LEN)
 ELSE(HAVE_SA_LEN)
   SET(HAVE_SA_LEN 0)
 ENDIF(HAVE_SA_LEN)
-  
+
 IF (ENABLE_IPV6)
   # Check if struct sockaddr_in6 contains sin6
   CHECK_STRUCT_HAS_MEMBER("struct sockaddr_in6" sin6_addr netinet/in.h HAVE_IPV6)
@@ -592,7 +598,7 @@ IF(HAVE_WARNINGS)
  MESSAGE(STATUS "   ************ NOTE: ************")
  MESSAGE(STATUS "   Warnings occurred during cmake configuration... Please see output")
  MESSAGE(STATUS "   *******************************")
-ENDIF(HAVE_WARNINGS) 
+ENDIF(HAVE_WARNINGS)
 
 ####################################################################
 # RPM SPEC                                                         #
diff -rupN openwsman-2.6.9/src/lib/wsman-soap.c openwsman-2.6.9-patched/src/lib/wsman-soap.c
--- openwsman-2.6.9/src/lib/wsman-soap.c	2018-11-20 09:09:43.000000000 +0100
+++ openwsman-2.6.9-patched/src/lib/wsman-soap.c	2019-08-01 15:28:56.000000000 +0200
@@ -935,16 +935,18 @@ unsigned long get_total_enum_context(WsC
  * to libwsman.la. So when a call is made to the following methods
  * from the openwsmand binary, they should be present.
  *
- * However, if they are dlopened from somewhere other than 
+ * However, if they are dlopened from somewhere other than
  * openwsmand library or linked to some other
  * binary or shared object, then these methods may or may not be
  * preset, hence marking them as weak symbols and testing to see
  * if they are resolved before using them.
  */
+#if 0
 #pragma weak wsmand_options_get_max_threads
 extern int wsmand_options_get_max_threads(void);
 #pragma weak wsmand_options_get_max_connections_per_thread
 extern int wsmand_options_get_max_connections_per_thread(void);
+#endif
 
 /**
  * Enumeration Stub for processing enumeration requests
@@ -975,9 +977,17 @@ wsenum_enumerate_stub(SoapOpH op,
         int max_threads = 0;
         int max_connections_per_thread = 0;
         int(* fptr)(void);
+#if 0
         if((fptr = wsmand_options_get_max_threads) != 0){
+#else
+				if (0) {
+#endif
                 max_threads = (* fptr)();
+#if 0
                 if((fptr = wsmand_options_get_max_connections_per_thread) != 0){
+#else
+								if (0) {
+#endif
                         max_connections_per_thread = (* fptr)();
                 }
                 else{
